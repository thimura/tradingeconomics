/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-cache";
exports.ids = ["vendor-chunks/node-cache"];
exports.modules = {

/***/ "(ssr)/./node_modules/node-cache/index.js":
/*!******************************************!*\
  !*** ./node_modules/node-cache/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var exports;\n\n  exports = module.exports = __webpack_require__(/*! ./lib/node_cache */ \"(ssr)/./node_modules/node-cache/lib/node_cache.js\");\n\n  exports.version = '5.1.2';\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1jYWNoZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksaUhBQTRDOztBQUV4RDs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGUtYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtY2FjaGUvaW5kZXguanM/MzI1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogbm9kZS1jYWNoZSA1LjEuMiAoIDIwMjAtMDctMDEgKVxuICogaHR0cHM6Ly9naXRodWIuY29tL25vZGUtY2FjaGUvbm9kZS1jYWNoZVxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL25vZGUtY2FjaGUvbm9kZS1jYWNoZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTWFpbnRhaW5lZCBieSAgKCAgKVxuKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIGV4cG9ydHM7XG5cbiAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvbm9kZV9jYWNoZScpO1xuXG4gIGV4cG9ydHMudmVyc2lvbiA9ICc1LjEuMic7XG5cbn0pLmNhbGwodGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-cache/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-cache/lib/node_cache.js":
/*!***************************************************!*\
  !*** ./node_modules/node-cache/lib/node_cache.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*\n * node-cache 5.1.2 ( 2020-07-01 )\n * https://github.com/node-cache/node-cache\n *\n * Released under the MIT license\n * https://github.com/node-cache/node-cache/blob/master/LICENSE\n *\n * Maintained by  (  )\n*/\n(function() {\n  var EventEmitter, NodeCache, clone,\n    splice = [].splice,\n    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } },\n    indexOf = [].indexOf;\n\n  clone = __webpack_require__(/*! clone */ \"(ssr)/./node_modules/clone/clone.js\");\n\n  EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\n  // generate superclass\n  module.exports = NodeCache = (function() {\n    class NodeCache extends EventEmitter {\n      constructor(options = {}) {\n        super();\n        // ## get\n\n        // get a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.get \"myKey\", ( err, val )\n\n        this.get = this.get.bind(this);\n        // ## mget\n\n        // get multiple cached keys at once and change the stats\n\n        // **Parameters:**\n\n        // * `keys` ( String|Number[] ): an array of keys\n\n        // **Example:**\n\n        //\tmyCache.mget [ \"foo\", \"bar\" ]\n\n        this.mget = this.mget.bind(this);\n        // ## set\n\n        // set a cached key and change the stats\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n        // * `value` ( Any ): A element to cache. If the option `option.forceString` is `true` the module trys to translate it to a serialized JSON\n        // * `[ ttl ]` ( Number | String ): ( optional ) The time to live in seconds.\n\n        // **Example:**\n\n        //\tmyCache.set \"myKey\", \"my_String Value\"\n\n        //\tmyCache.set \"myKey\", \"my_String Value\", 10\n\n        this.set = this.set.bind(this);\n        \n        // ## mset\n\n        // set multiple keys at once\n\n        // **Parameters:**\n\n        // * `keyValueSet` ( Object[] ): an array of object which includes key,value and ttl\n\n        // **Example:**\n\n        //\tmyCache.mset(\n        //\t\t[\n        //\t\t\t{\n        //\t\t\t\tkey: \"myKey\",\n        //\t\t\t\tval: \"myValue\",\n        //\t\t\t\tttl: [ttl in seconds]\n        //\t\t\t}\n        //\t\t])\n\n        this.mset = this.mset.bind(this);\n        // ## del\n\n        // remove keys\n\n        // **Parameters:**\n\n        // * `keys` ( String |Â Number | String|Number[] ): cache key to delete or a array of cache keys\n\n        // **Return**\n\n        // ( Number ): Number of deleted keys\n\n        // **Example:**\n\n        //\tmyCache.del( \"myKey\" )\n\n        this.del = this.del.bind(this);\n        // ## take\n\n        // get the cached value and remove the key from the cache.\n        // Equivalent to calling `get(key)` + `del(key)`.\n        // Useful for implementing `single use` mechanism such as OTP, where once a value is read it will become obsolete.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key\n\n        // **Example:**\n\n        //\tmyCache.take \"myKey\", ( err, val )\n\n        this.take = this.take.bind(this);\n        // ## ttl\n\n        // reset or redefine the ttl of a key. `ttl` = 0 means infinite lifetime.\n        // If `ttl` is not passed the default ttl is used.\n        // If `ttl` < 0 the key will be deleted.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to reset the ttl value\n        // * `ttl` ( Number ): ( optional -> options.stdTTL || 0 ) The time to live in seconds\n\n        // **Return**\n\n        // ( Boolen ): key found and ttl set\n\n        // **Example:**\n\n        //\tmyCache.ttl( \"myKey\" ) // will set ttl to default ttl\n\n        //\tmyCache.ttl( \"myKey\", 1000 )\n\n        this.ttl = this.ttl.bind(this);\n        // ## getTtl\n\n        // receive the ttl of a key.\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Number|undefined ): The timestamp in ms when the key will expire, 0 if it will never expire or undefined if it not exists\n\n        // **Example:**\n\n        //\tmyCache.getTtl( \"myKey\" )\n\n        this.getTtl = this.getTtl.bind(this);\n        // ## keys\n\n        // list all keys within this cache\n\n        // **Return**\n\n        // ( Array ): An array of all keys\n\n        // **Example:**\n\n        //     _keys = myCache.keys()\n\n        //     # [ \"foo\", \"bar\", \"fizz\", \"buzz\", \"anotherKeys\" ]\n\n        this.keys = this.keys.bind(this);\n        // ## has\n\n        // Check if a key is cached\n\n        // **Parameters:**\n\n        // * `key` ( String | Number ): cache key to check the ttl value\n\n        // **Return**\n\n        // ( Boolean ): A boolean that indicates if the key is cached\n\n        // **Example:**\n\n        //     _exists = myCache.has('myKey')\n\n        //     # true\n\n        this.has = this.has.bind(this);\n        // ## getStats\n\n        // get the stats\n\n        // **Parameters:**\n\n        // -\n\n        // **Return**\n\n        // ( Object ): Stats data\n\n        // **Example:**\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.getStats = this.getStats.bind(this);\n        // ## flushAll\n\n        // flush the whole data and reset the stats\n\n        // **Example:**\n\n        //     myCache.flushAll()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushAll = this.flushAll.bind(this);\n        \n        // ## flushStats\n\n        // flush the stats and reset all counters to 0\n\n        // **Example:**\n\n        //     myCache.flushStats()\n\n        //     myCache.getStats()\n        //     # {\n        //     # hits: 0,\n        //     # misses: 0,\n        //     # keys: 0,\n        //     # ksize: 0,\n        //     # vsize: 0\n        //     # }\n\n        this.flushStats = this.flushStats.bind(this);\n        // ## close\n\n        // This will clear the interval timeout which is set on checkperiod option.\n\n        // **Example:**\n\n        //     myCache.close()\n\n        this.close = this.close.bind(this);\n        // ## _checkData\n\n        // internal housekeeping method.\n        // Check all the cached data and delete the invalid values\n        this._checkData = this._checkData.bind(this);\n        // ## _check\n\n        // internal method the check the value. If it's not valid any more delete it\n        this._check = this._check.bind(this);\n        // ## _isInvalidKey\n\n        // internal method to check if the type of a key is either `number` or `string`\n        this._isInvalidKey = this._isInvalidKey.bind(this);\n        // ## _wrap\n\n        // internal method to wrap a value in an object with some metadata\n        this._wrap = this._wrap.bind(this);\n        // ## _getValLength\n\n        // internal method to calculate the value length\n        this._getValLength = this._getValLength.bind(this);\n        // ## _error\n\n        // internal method to handle an error message\n        this._error = this._error.bind(this);\n        // ## _initErrors\n\n        // internal method to generate error message templates\n        this._initErrors = this._initErrors.bind(this);\n        this.options = options;\n        this._initErrors();\n        // container for cached data\n        this.data = {};\n        // module options\n        this.options = Object.assign({\n          // convert all elements to string\n          forceString: false,\n          // used standard size for calculating value size\n          objectValueSize: 80,\n          promiseValueSize: 80,\n          arrayValueSize: 40,\n          // standard time to live in seconds. 0 = infinity;\n          stdTTL: 0,\n          // time in seconds to check all data and delete expired keys\n          checkperiod: 600,\n          // en/disable cloning of variables. If `true` you'll get a copy of the cached variable. If `false` you'll save and get just the reference\n          useClones: true,\n          // whether values should be deleted automatically at expiration\n          deleteOnExpire: true,\n          // enable legacy callbacks\n          enableLegacyCallbacks: false,\n          // max amount of keys that are being stored\n          maxKeys: -1\n        }, this.options);\n        // generate functions with callbacks (legacy)\n        if (this.options.enableLegacyCallbacks) {\n          console.warn(\"WARNING! node-cache legacy callback support will drop in v6.x\");\n          [\"get\", \"mget\", \"set\", \"del\", \"ttl\", \"getTtl\", \"keys\", \"has\"].forEach((methodKey) => {\n            var oldMethod;\n            // reference real function\n            oldMethod = this[methodKey];\n            this[methodKey] = function(...args) {\n              var cb, err, ref, res;\n              ref = args, [...args] = ref, [cb] = splice.call(args, -1);\n              // return a callback if cb is defined and a function\n              if (typeof cb === \"function\") {\n                try {\n                  res = oldMethod(...args);\n                  cb(null, res);\n                } catch (error1) {\n                  err = error1;\n                  cb(err);\n                }\n              } else {\n                return oldMethod(...args, cb);\n              }\n            };\n          });\n        }\n        // statistics container\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // pre allocate valid keytypes array\n        this.validKeyTypes = [\"string\", \"number\"];\n        // initalize checking period\n        this._checkData();\n        return;\n      }\n\n      get(key) {\n        var _ret, err;\n        boundMethodCheck(this, NodeCache);\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // get data and incremet stats\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          this.stats.hits++;\n          _ret = this._unwrap(this.data[key]);\n          // return data\n          return _ret;\n        } else {\n          // if not found return undefined\n          this.stats.misses++;\n          return void 0;\n        }\n      }\n\n      mget(keys) {\n        var _err, err, i, key, len, oRet;\n        boundMethodCheck(this, NodeCache);\n        // convert a string to an array of one key\n        if (!Array.isArray(keys)) {\n          _err = this._error(\"EKEYSTYPE\");\n          throw _err;\n        }\n        // define return\n        oRet = {};\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // get data and increment stats\n          if ((this.data[key] != null) && this._check(key, this.data[key])) {\n            this.stats.hits++;\n            oRet[key] = this._unwrap(this.data[key]);\n          } else {\n            // if not found return a error\n            this.stats.misses++;\n          }\n        }\n        // return all found keys\n        return oRet;\n      }\n\n      set(key, value, ttl) {\n        var _err, err, existent;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n        // force the data to string\n        if (this.options.forceString && !typeof value === \"string\") {\n          value = JSON.stringify(value);\n        }\n        // set default ttl if not passed\n        if (ttl == null) {\n          ttl = this.options.stdTTL;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // internal helper variables\n        existent = false;\n        // remove existing data from stats\n        if (this.data[key]) {\n          existent = true;\n          this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n        }\n        // set the value\n        this.data[key] = this._wrap(value, ttl);\n        this.stats.vsize += this._getValLength(value);\n        // only add the keys and key-size if the key is new\n        if (!existent) {\n          this.stats.ksize += this._getKeyLength(key);\n          this.stats.keys++;\n        }\n        this.emit(\"set\", key, value);\n        // return true\n        return true;\n      }\n\n      mset(keyValueSet) {\n        var _err, err, i, j, key, keyValuePair, len, len1, ttl, val;\n        boundMethodCheck(this, NodeCache);\n        // check if cache is overflowing\n        if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {\n          _err = this._error(\"ECACHEFULL\");\n          throw _err;\n        }\n\n// loop over keyValueSet to validate key and ttl\n        for (i = 0, len = keyValueSet.length; i < len; i++) {\n          keyValuePair = keyValueSet[i];\n          ({key, val, ttl} = keyValuePair);\n          // check if there is ttl and it's a number\n          if (ttl && typeof ttl !== \"number\") {\n            _err = this._error(\"ETTLTYPE\");\n            throw _err;\n          }\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n        }\n        for (j = 0, len1 = keyValueSet.length; j < len1; j++) {\n          keyValuePair = keyValueSet[j];\n          ({key, val, ttl} = keyValuePair);\n          this.set(key, val, ttl);\n        }\n        return true;\n      }\n\n      del(keys) {\n        var delCount, err, i, key, len, oldVal;\n        boundMethodCheck(this, NodeCache);\n        // convert keys to an array of itself\n        if (!Array.isArray(keys)) {\n          keys = [keys];\n        }\n        delCount = 0;\n        for (i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          // handle invalid key types\n          if ((err = this._isInvalidKey(key)) != null) {\n            throw err;\n          }\n          // only delete if existent\n          if (this.data[key] != null) {\n            // calc the stats\n            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));\n            this.stats.ksize -= this._getKeyLength(key);\n            this.stats.keys--;\n            delCount++;\n            // delete the value\n            oldVal = this.data[key];\n            delete this.data[key];\n            // return true\n            this.emit(\"del\", key, oldVal.v);\n          }\n        }\n        return delCount;\n      }\n\n      take(key) {\n        var _ret;\n        boundMethodCheck(this, NodeCache);\n        _ret = this.get(key);\n        if ((_ret != null)) {\n          this.del(key);\n        }\n        return _ret;\n      }\n\n      ttl(key, ttl) {\n        var err;\n        boundMethodCheck(this, NodeCache);\n        ttl || (ttl = this.options.stdTTL);\n        if (!key) {\n          return false;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existent data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          // if ttl < 0 delete the key. otherwise reset the value\n          if (ttl >= 0) {\n            this.data[key] = this._wrap(this.data[key].v, ttl, false);\n          } else {\n            this.del(key);\n          }\n          return true;\n        } else {\n          // return false if key has not been found\n          return false;\n        }\n      }\n\n      getTtl(key) {\n        var _ttl, err;\n        boundMethodCheck(this, NodeCache);\n        if (!key) {\n          return void 0;\n        }\n        // handle invalid key types\n        if ((err = this._isInvalidKey(key)) != null) {\n          throw err;\n        }\n        // check for existant data and update the ttl value\n        if ((this.data[key] != null) && this._check(key, this.data[key])) {\n          _ttl = this.data[key].t;\n          return _ttl;\n        } else {\n          // return undefined if key has not been found\n          return void 0;\n        }\n      }\n\n      keys() {\n        var _keys;\n        boundMethodCheck(this, NodeCache);\n        _keys = Object.keys(this.data);\n        return _keys;\n      }\n\n      has(key) {\n        var _exists;\n        boundMethodCheck(this, NodeCache);\n        _exists = (this.data[key] != null) && this._check(key, this.data[key]);\n        return _exists;\n      }\n\n      getStats() {\n        boundMethodCheck(this, NodeCache);\n        return this.stats;\n      }\n\n      flushAll(_startPeriod = true) {\n        boundMethodCheck(this, NodeCache);\n        // parameter just for testing\n\n        // set data empty\n        this.data = {};\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        // reset check period\n        this._killCheckPeriod();\n        this._checkData(_startPeriod);\n        this.emit(\"flush\");\n      }\n\n      flushStats() {\n        boundMethodCheck(this, NodeCache);\n        // reset stats\n        this.stats = {\n          hits: 0,\n          misses: 0,\n          keys: 0,\n          ksize: 0,\n          vsize: 0\n        };\n        this.emit(\"flush_stats\");\n      }\n\n      close() {\n        boundMethodCheck(this, NodeCache);\n        this._killCheckPeriod();\n      }\n\n      _checkData(startPeriod = true) {\n        var key, ref, value;\n        boundMethodCheck(this, NodeCache);\n        ref = this.data;\n        // run the housekeeping method\n        for (key in ref) {\n          value = ref[key];\n          this._check(key, value);\n        }\n        if (startPeriod && this.options.checkperiod > 0) {\n          this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);\n          if ((this.checkTimeout != null) && (this.checkTimeout.unref != null)) {\n            this.checkTimeout.unref();\n          }\n        }\n      }\n\n      // ## _killCheckPeriod\n\n      // stop the checkdata period. Only needed to abort the script in testing mode.\n      _killCheckPeriod() {\n        if (this.checkTimeout != null) {\n          return clearTimeout(this.checkTimeout);\n        }\n      }\n\n      _check(key, data) {\n        var _retval;\n        boundMethodCheck(this, NodeCache);\n        _retval = true;\n        // data is invalid if the ttl is too old and is not 0\n        // console.log data.t < Date.now(), data.t, Date.now()\n        if (data.t !== 0 && data.t < Date.now()) {\n          if (this.options.deleteOnExpire) {\n            _retval = false;\n            this.del(key);\n          }\n          this.emit(\"expired\", key, this._unwrap(data));\n        }\n        return _retval;\n      }\n\n      _isInvalidKey(key) {\n        var ref;\n        boundMethodCheck(this, NodeCache);\n        if (ref = typeof key, indexOf.call(this.validKeyTypes, ref) < 0) {\n          return this._error(\"EKEYTYPE\", {\n            type: typeof key\n          });\n        }\n      }\n\n      _wrap(value, ttl, asClone = true) {\n        var livetime, now, oReturn, ttlMultiplicator;\n        boundMethodCheck(this, NodeCache);\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        // define the time to live\n        now = Date.now();\n        livetime = 0;\n        ttlMultiplicator = 1000;\n        // use given ttl\n        if (ttl === 0) {\n          livetime = 0;\n        } else if (ttl) {\n          livetime = now + (ttl * ttlMultiplicator);\n        } else {\n          // use standard ttl\n          if (this.options.stdTTL === 0) {\n            livetime = this.options.stdTTL;\n          } else {\n            livetime = now + (this.options.stdTTL * ttlMultiplicator);\n          }\n        }\n        // return the wrapped value\n        return oReturn = {\n          t: livetime,\n          v: asClone ? clone(value) : value\n        };\n      }\n\n      // ## _unwrap\n\n      // internal method to extract get the value out of the wrapped value\n      _unwrap(value, asClone = true) {\n        if (!this.options.useClones) {\n          asClone = false;\n        }\n        if (value.v != null) {\n          if (asClone) {\n            return clone(value.v);\n          } else {\n            return value.v;\n          }\n        }\n        return null;\n      }\n\n      // ## _getKeyLength\n\n      // internal method the calculate the key length\n      _getKeyLength(key) {\n        return key.toString().length;\n      }\n\n      _getValLength(value) {\n        boundMethodCheck(this, NodeCache);\n        if (typeof value === \"string\") {\n          // if the value is a String get the real length\n          return value.length;\n        } else if (this.options.forceString) {\n          // force string if it's defined and not passed\n          return JSON.stringify(value).length;\n        } else if (Array.isArray(value)) {\n          // if the data is an Array multiply each element with a defined default length\n          return this.options.arrayValueSize * value.length;\n        } else if (typeof value === \"number\") {\n          return 8;\n        } else if (typeof (value != null ? value.then : void 0) === \"function\") {\n          // if the data is a Promise, use defined default\n          // (can't calculate actual/resolved value size synchronously)\n          return this.options.promiseValueSize;\n        } else if (typeof Buffer !== \"undefined\" && Buffer !== null ? Buffer.isBuffer(value) : void 0) {\n          return value.length;\n        } else if ((value != null) && typeof value === \"object\") {\n          // if the data is an Object multiply each element with a defined default length\n          return this.options.objectValueSize * Object.keys(value).length;\n        } else if (typeof value === \"boolean\") {\n          return 8;\n        } else {\n          // default fallback\n          return 0;\n        }\n      }\n\n      _error(type, data = {}) {\n        var error;\n        boundMethodCheck(this, NodeCache);\n        // generate the error object\n        error = new Error();\n        error.name = type;\n        error.errorcode = type;\n        error.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : \"-\";\n        error.data = data;\n        // return the error object\n        return error;\n      }\n\n      _initErrors() {\n        var _errMsg, _errT, ref;\n        boundMethodCheck(this, NodeCache);\n        this.ERRORS = {};\n        ref = this._ERRORS;\n        for (_errT in ref) {\n          _errMsg = ref[_errT];\n          this.ERRORS[_errT] = this.createErrorMessage(_errMsg);\n        }\n      }\n\n      createErrorMessage(errMsg) {\n        return function(args) {\n          return errMsg.replace(\"__key\", args.type);\n        };\n      }\n\n    };\n\n    NodeCache.prototype._ERRORS = {\n      \"ENOTFOUND\": \"Key `__key` not found\",\n      \"ECACHEFULL\": \"Cache max keys amount exceeded\",\n      \"EKEYTYPE\": \"The key argument has to be of type `string` or `number`. Found: `__key`\",\n      \"EKEYSTYPE\": \"The keys argument has to be an array.\",\n      \"ETTLTYPE\": \"The ttl argument has to be a number.\"\n    };\n\n    return NodeCache;\n\n  }).call(this);\n\n}).call(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1jYWNoZS9saWIvbm9kZV9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsMENBQTBDLHFFQUFxRTtBQUN4Szs7QUFFQSxVQUFVLG1CQUFPLENBQUMsa0RBQU87O0FBRXpCLGlCQUFpQiwwREFBOEI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGUtYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtY2FjaGUvbGliL25vZGVfY2FjaGUuanM/MDE3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogbm9kZS1jYWNoZSA1LjEuMiAoIDIwMjAtMDctMDEgKVxuICogaHR0cHM6Ly9naXRodWIuY29tL25vZGUtY2FjaGUvbm9kZS1jYWNoZVxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL25vZGUtY2FjaGUvbm9kZS1jYWNoZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogTWFpbnRhaW5lZCBieSAgKCAgKVxuKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIEV2ZW50RW1pdHRlciwgTm9kZUNhY2hlLCBjbG9uZSxcbiAgICBzcGxpY2UgPSBbXS5zcGxpY2UsXG4gICAgYm91bmRNZXRob2RDaGVjayA9IGZ1bmN0aW9uKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgRXJyb3IoJ0JvdW5kIGluc3RhbmNlIG1ldGhvZCBhY2Nlc3NlZCBiZWZvcmUgYmluZGluZycpOyB9IH0sXG4gICAgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbiAgY2xvbmUgPSByZXF1aXJlKFwiY2xvbmVcIik7XG5cbiAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4gIC8vIGdlbmVyYXRlIHN1cGVyY2xhc3NcbiAgbW9kdWxlLmV4cG9ydHMgPSBOb2RlQ2FjaGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgY2xhc3MgTm9kZUNhY2hlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyAjIyBnZXRcblxuICAgICAgICAvLyBnZXQgYSBjYWNoZWQga2V5IGFuZCBjaGFuZ2UgdGhlIHN0YXRzXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXlcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS5nZXQgXCJteUtleVwiLCAoIGVyciwgdmFsIClcblxuICAgICAgICB0aGlzLmdldCA9IHRoaXMuZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIG1nZXRcblxuICAgICAgICAvLyBnZXQgbXVsdGlwbGUgY2FjaGVkIGtleXMgYXQgb25jZSBhbmQgY2hhbmdlIHRoZSBzdGF0c1xuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleXNgICggU3RyaW5nfE51bWJlcltdICk6IGFuIGFycmF5IG9mIGtleXNcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS5tZ2V0IFsgXCJmb29cIiwgXCJiYXJcIiBdXG5cbiAgICAgICAgdGhpcy5tZ2V0ID0gdGhpcy5tZ2V0LmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIHNldFxuXG4gICAgICAgIC8vIHNldCBhIGNhY2hlZCBrZXkgYW5kIGNoYW5nZSB0aGUgc3RhdHNcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlgICggU3RyaW5nIHwgTnVtYmVyICk6IGNhY2hlIGtleVxuICAgICAgICAvLyAqIGB2YWx1ZWAgKCBBbnkgKTogQSBlbGVtZW50IHRvIGNhY2hlLiBJZiB0aGUgb3B0aW9uIGBvcHRpb24uZm9yY2VTdHJpbmdgIGlzIGB0cnVlYCB0aGUgbW9kdWxlIHRyeXMgdG8gdHJhbnNsYXRlIGl0IHRvIGEgc2VyaWFsaXplZCBKU09OXG4gICAgICAgIC8vICogYFsgdHRsIF1gICggTnVtYmVyIHwgU3RyaW5nICk6ICggb3B0aW9uYWwgKSBUaGUgdGltZSB0byBsaXZlIGluIHNlY29uZHMuXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUuc2V0IFwibXlLZXlcIiwgXCJteV9TdHJpbmcgVmFsdWVcIlxuXG4gICAgICAgIC8vXHRteUNhY2hlLnNldCBcIm15S2V5XCIsIFwibXlfU3RyaW5nIFZhbHVlXCIsIDEwXG5cbiAgICAgICAgdGhpcy5zZXQgPSB0aGlzLnNldC5iaW5kKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gIyMgbXNldFxuXG4gICAgICAgIC8vIHNldCBtdWx0aXBsZSBrZXlzIGF0IG9uY2VcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlWYWx1ZVNldGAgKCBPYmplY3RbXSApOiBhbiBhcnJheSBvZiBvYmplY3Qgd2hpY2ggaW5jbHVkZXMga2V5LHZhbHVlIGFuZCB0dGxcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS5tc2V0KFxuICAgICAgICAvL1x0XHRbXG4gICAgICAgIC8vXHRcdFx0e1xuICAgICAgICAvL1x0XHRcdFx0a2V5OiBcIm15S2V5XCIsXG4gICAgICAgIC8vXHRcdFx0XHR2YWw6IFwibXlWYWx1ZVwiLFxuICAgICAgICAvL1x0XHRcdFx0dHRsOiBbdHRsIGluIHNlY29uZHNdXG4gICAgICAgIC8vXHRcdFx0fVxuICAgICAgICAvL1x0XHRdKVxuXG4gICAgICAgIHRoaXMubXNldCA9IHRoaXMubXNldC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBkZWxcblxuICAgICAgICAvLyByZW1vdmUga2V5c1xuXG4gICAgICAgIC8vICoqUGFyYW1ldGVyczoqKlxuXG4gICAgICAgIC8vICogYGtleXNgICggU3RyaW5nIHzCoE51bWJlciB8IFN0cmluZ3xOdW1iZXJbXSApOiBjYWNoZSBrZXkgdG8gZGVsZXRlIG9yIGEgYXJyYXkgb2YgY2FjaGUga2V5c1xuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIE51bWJlciApOiBOdW1iZXIgb2YgZGVsZXRlZCBrZXlzXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy9cdG15Q2FjaGUuZGVsKCBcIm15S2V5XCIgKVxuXG4gICAgICAgIHRoaXMuZGVsID0gdGhpcy5kZWwuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgdGFrZVxuXG4gICAgICAgIC8vIGdldCB0aGUgY2FjaGVkIHZhbHVlIGFuZCByZW1vdmUgdGhlIGtleSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgICAgLy8gRXF1aXZhbGVudCB0byBjYWxsaW5nIGBnZXQoa2V5KWAgKyBgZGVsKGtleSlgLlxuICAgICAgICAvLyBVc2VmdWwgZm9yIGltcGxlbWVudGluZyBgc2luZ2xlIHVzZWAgbWVjaGFuaXNtIHN1Y2ggYXMgT1RQLCB3aGVyZSBvbmNlIGEgdmFsdWUgaXMgcmVhZCBpdCB3aWxsIGJlY29tZSBvYnNvbGV0ZS5cblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlgICggU3RyaW5nIHwgTnVtYmVyICk6IGNhY2hlIGtleVxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLnRha2UgXCJteUtleVwiLCAoIGVyciwgdmFsIClcblxuICAgICAgICB0aGlzLnRha2UgPSB0aGlzLnRha2UuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgdHRsXG5cbiAgICAgICAgLy8gcmVzZXQgb3IgcmVkZWZpbmUgdGhlIHR0bCBvZiBhIGtleS4gYHR0bGAgPSAwIG1lYW5zIGluZmluaXRlIGxpZmV0aW1lLlxuICAgICAgICAvLyBJZiBgdHRsYCBpcyBub3QgcGFzc2VkIHRoZSBkZWZhdWx0IHR0bCBpcyB1c2VkLlxuICAgICAgICAvLyBJZiBgdHRsYCA8IDAgdGhlIGtleSB3aWxsIGJlIGRlbGV0ZWQuXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gKiBga2V5YCAoIFN0cmluZyB8IE51bWJlciApOiBjYWNoZSBrZXkgdG8gcmVzZXQgdGhlIHR0bCB2YWx1ZVxuICAgICAgICAvLyAqIGB0dGxgICggTnVtYmVyICk6ICggb3B0aW9uYWwgLT4gb3B0aW9ucy5zdGRUVEwgfHwgMCApIFRoZSB0aW1lIHRvIGxpdmUgaW4gc2Vjb25kc1xuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIEJvb2xlbiApOiBrZXkgZm91bmQgYW5kIHR0bCBzZXRcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvL1x0bXlDYWNoZS50dGwoIFwibXlLZXlcIiApIC8vIHdpbGwgc2V0IHR0bCB0byBkZWZhdWx0IHR0bFxuXG4gICAgICAgIC8vXHRteUNhY2hlLnR0bCggXCJteUtleVwiLCAxMDAwIClcblxuICAgICAgICB0aGlzLnR0bCA9IHRoaXMudHRsLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIGdldFR0bFxuXG4gICAgICAgIC8vIHJlY2VpdmUgdGhlIHR0bCBvZiBhIGtleS5cblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlgICggU3RyaW5nIHwgTnVtYmVyICk6IGNhY2hlIGtleSB0byBjaGVjayB0aGUgdHRsIHZhbHVlXG5cbiAgICAgICAgLy8gKipSZXR1cm4qKlxuXG4gICAgICAgIC8vICggTnVtYmVyfHVuZGVmaW5lZCApOiBUaGUgdGltZXN0YW1wIGluIG1zIHdoZW4gdGhlIGtleSB3aWxsIGV4cGlyZSwgMCBpZiBpdCB3aWxsIG5ldmVyIGV4cGlyZSBvciB1bmRlZmluZWQgaWYgaXQgbm90IGV4aXN0c1xuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vXHRteUNhY2hlLmdldFR0bCggXCJteUtleVwiIClcblxuICAgICAgICB0aGlzLmdldFR0bCA9IHRoaXMuZ2V0VHRsLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIGtleXNcblxuICAgICAgICAvLyBsaXN0IGFsbCBrZXlzIHdpdGhpbiB0aGlzIGNhY2hlXG5cbiAgICAgICAgLy8gKipSZXR1cm4qKlxuXG4gICAgICAgIC8vICggQXJyYXkgKTogQW4gYXJyYXkgb2YgYWxsIGtleXNcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvLyAgICAgX2tleXMgPSBteUNhY2hlLmtleXMoKVxuXG4gICAgICAgIC8vICAgICAjIFsgXCJmb29cIiwgXCJiYXJcIiwgXCJmaXp6XCIsIFwiYnV6elwiLCBcImFub3RoZXJLZXlzXCIgXVxuXG4gICAgICAgIHRoaXMua2V5cyA9IHRoaXMua2V5cy5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBoYXNcblxuICAgICAgICAvLyBDaGVjayBpZiBhIGtleSBpcyBjYWNoZWRcblxuICAgICAgICAvLyAqKlBhcmFtZXRlcnM6KipcblxuICAgICAgICAvLyAqIGBrZXlgICggU3RyaW5nIHwgTnVtYmVyICk6IGNhY2hlIGtleSB0byBjaGVjayB0aGUgdHRsIHZhbHVlXG5cbiAgICAgICAgLy8gKipSZXR1cm4qKlxuXG4gICAgICAgIC8vICggQm9vbGVhbiApOiBBIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGtleSBpcyBjYWNoZWRcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvLyAgICAgX2V4aXN0cyA9IG15Q2FjaGUuaGFzKCdteUtleScpXG5cbiAgICAgICAgLy8gICAgICMgdHJ1ZVxuXG4gICAgICAgIHRoaXMuaGFzID0gdGhpcy5oYXMuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgZ2V0U3RhdHNcblxuICAgICAgICAvLyBnZXQgdGhlIHN0YXRzXG5cbiAgICAgICAgLy8gKipQYXJhbWV0ZXJzOioqXG5cbiAgICAgICAgLy8gLVxuXG4gICAgICAgIC8vICoqUmV0dXJuKipcblxuICAgICAgICAvLyAoIE9iamVjdCApOiBTdGF0cyBkYXRhXG5cbiAgICAgICAgLy8gKipFeGFtcGxlOioqXG5cbiAgICAgICAgLy8gICAgIG15Q2FjaGUuZ2V0U3RhdHMoKVxuICAgICAgICAvLyAgICAgIyB7XG4gICAgICAgIC8vICAgICAjIGhpdHM6IDAsXG4gICAgICAgIC8vICAgICAjIG1pc3NlczogMCxcbiAgICAgICAgLy8gICAgICMga2V5czogMCxcbiAgICAgICAgLy8gICAgICMga3NpemU6IDAsXG4gICAgICAgIC8vICAgICAjIHZzaXplOiAwXG4gICAgICAgIC8vICAgICAjIH1cblxuICAgICAgICB0aGlzLmdldFN0YXRzID0gdGhpcy5nZXRTdGF0cy5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBmbHVzaEFsbFxuXG4gICAgICAgIC8vIGZsdXNoIHRoZSB3aG9sZSBkYXRhIGFuZCByZXNldCB0aGUgc3RhdHNcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvLyAgICAgbXlDYWNoZS5mbHVzaEFsbCgpXG5cbiAgICAgICAgLy8gICAgIG15Q2FjaGUuZ2V0U3RhdHMoKVxuICAgICAgICAvLyAgICAgIyB7XG4gICAgICAgIC8vICAgICAjIGhpdHM6IDAsXG4gICAgICAgIC8vICAgICAjIG1pc3NlczogMCxcbiAgICAgICAgLy8gICAgICMga2V5czogMCxcbiAgICAgICAgLy8gICAgICMga3NpemU6IDAsXG4gICAgICAgIC8vICAgICAjIHZzaXplOiAwXG4gICAgICAgIC8vICAgICAjIH1cblxuICAgICAgICB0aGlzLmZsdXNoQWxsID0gdGhpcy5mbHVzaEFsbC5iaW5kKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gIyMgZmx1c2hTdGF0c1xuXG4gICAgICAgIC8vIGZsdXNoIHRoZSBzdGF0cyBhbmQgcmVzZXQgYWxsIGNvdW50ZXJzIHRvIDBcblxuICAgICAgICAvLyAqKkV4YW1wbGU6KipcblxuICAgICAgICAvLyAgICAgbXlDYWNoZS5mbHVzaFN0YXRzKClcblxuICAgICAgICAvLyAgICAgbXlDYWNoZS5nZXRTdGF0cygpXG4gICAgICAgIC8vICAgICAjIHtcbiAgICAgICAgLy8gICAgICMgaGl0czogMCxcbiAgICAgICAgLy8gICAgICMgbWlzc2VzOiAwLFxuICAgICAgICAvLyAgICAgIyBrZXlzOiAwLFxuICAgICAgICAvLyAgICAgIyBrc2l6ZTogMCxcbiAgICAgICAgLy8gICAgICMgdnNpemU6IDBcbiAgICAgICAgLy8gICAgICMgfVxuXG4gICAgICAgIHRoaXMuZmx1c2hTdGF0cyA9IHRoaXMuZmx1c2hTdGF0cy5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBjbG9zZVxuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBjbGVhciB0aGUgaW50ZXJ2YWwgdGltZW91dCB3aGljaCBpcyBzZXQgb24gY2hlY2twZXJpb2Qgb3B0aW9uLlxuXG4gICAgICAgIC8vICoqRXhhbXBsZToqKlxuXG4gICAgICAgIC8vICAgICBteUNhY2hlLmNsb3NlKClcblxuICAgICAgICB0aGlzLmNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfY2hlY2tEYXRhXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgaG91c2VrZWVwaW5nIG1ldGhvZC5cbiAgICAgICAgLy8gQ2hlY2sgYWxsIHRoZSBjYWNoZWQgZGF0YSBhbmQgZGVsZXRlIHRoZSBpbnZhbGlkIHZhbHVlc1xuICAgICAgICB0aGlzLl9jaGVja0RhdGEgPSB0aGlzLl9jaGVja0RhdGEuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gIyMgX2NoZWNrXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRoZSBjaGVjayB0aGUgdmFsdWUuIElmIGl0J3Mgbm90IHZhbGlkIGFueSBtb3JlIGRlbGV0ZSBpdFxuICAgICAgICB0aGlzLl9jaGVjayA9IHRoaXMuX2NoZWNrLmJpbmQodGhpcyk7XG4gICAgICAgIC8vICMjIF9pc0ludmFsaWRLZXlcblxuICAgICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gY2hlY2sgaWYgdGhlIHR5cGUgb2YgYSBrZXkgaXMgZWl0aGVyIGBudW1iZXJgIG9yIGBzdHJpbmdgXG4gICAgICAgIHRoaXMuX2lzSW52YWxpZEtleSA9IHRoaXMuX2lzSW52YWxpZEtleS5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfd3JhcFxuXG4gICAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0byB3cmFwIGEgdmFsdWUgaW4gYW4gb2JqZWN0IHdpdGggc29tZSBtZXRhZGF0YVxuICAgICAgICB0aGlzLl93cmFwID0gdGhpcy5fd3JhcC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfZ2V0VmFsTGVuZ3RoXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgbWV0aG9kIHRvIGNhbGN1bGF0ZSB0aGUgdmFsdWUgbGVuZ3RoXG4gICAgICAgIHRoaXMuX2dldFZhbExlbmd0aCA9IHRoaXMuX2dldFZhbExlbmd0aC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfZXJyb3JcblxuICAgICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdG8gaGFuZGxlIGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5fZXJyb3IgPSB0aGlzLl9lcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICAvLyAjIyBfaW5pdEVycm9yc1xuXG4gICAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBnZW5lcmF0ZSBlcnJvciBtZXNzYWdlIHRlbXBsYXRlc1xuICAgICAgICB0aGlzLl9pbml0RXJyb3JzID0gdGhpcy5faW5pdEVycm9ycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9pbml0RXJyb3JzKCk7XG4gICAgICAgIC8vIGNvbnRhaW5lciBmb3IgY2FjaGVkIGRhdGFcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIC8vIG1vZHVsZSBvcHRpb25zXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIC8vIGNvbnZlcnQgYWxsIGVsZW1lbnRzIHRvIHN0cmluZ1xuICAgICAgICAgIGZvcmNlU3RyaW5nOiBmYWxzZSxcbiAgICAgICAgICAvLyB1c2VkIHN0YW5kYXJkIHNpemUgZm9yIGNhbGN1bGF0aW5nIHZhbHVlIHNpemVcbiAgICAgICAgICBvYmplY3RWYWx1ZVNpemU6IDgwLFxuICAgICAgICAgIHByb21pc2VWYWx1ZVNpemU6IDgwLFxuICAgICAgICAgIGFycmF5VmFsdWVTaXplOiA0MCxcbiAgICAgICAgICAvLyBzdGFuZGFyZCB0aW1lIHRvIGxpdmUgaW4gc2Vjb25kcy4gMCA9IGluZmluaXR5O1xuICAgICAgICAgIHN0ZFRUTDogMCxcbiAgICAgICAgICAvLyB0aW1lIGluIHNlY29uZHMgdG8gY2hlY2sgYWxsIGRhdGEgYW5kIGRlbGV0ZSBleHBpcmVkIGtleXNcbiAgICAgICAgICBjaGVja3BlcmlvZDogNjAwLFxuICAgICAgICAgIC8vIGVuL2Rpc2FibGUgY2xvbmluZyBvZiB2YXJpYWJsZXMuIElmIGB0cnVlYCB5b3UnbGwgZ2V0IGEgY29weSBvZiB0aGUgY2FjaGVkIHZhcmlhYmxlLiBJZiBgZmFsc2VgIHlvdSdsbCBzYXZlIGFuZCBnZXQganVzdCB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgdXNlQ2xvbmVzOiB0cnVlLFxuICAgICAgICAgIC8vIHdoZXRoZXIgdmFsdWVzIHNob3VsZCBiZSBkZWxldGVkIGF1dG9tYXRpY2FsbHkgYXQgZXhwaXJhdGlvblxuICAgICAgICAgIGRlbGV0ZU9uRXhwaXJlOiB0cnVlLFxuICAgICAgICAgIC8vIGVuYWJsZSBsZWdhY3kgY2FsbGJhY2tzXG4gICAgICAgICAgZW5hYmxlTGVnYWN5Q2FsbGJhY2tzOiBmYWxzZSxcbiAgICAgICAgICAvLyBtYXggYW1vdW50IG9mIGtleXMgdGhhdCBhcmUgYmVpbmcgc3RvcmVkXG4gICAgICAgICAgbWF4S2V5czogLTFcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgZnVuY3Rpb25zIHdpdGggY2FsbGJhY2tzIChsZWdhY3kpXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlTGVnYWN5Q2FsbGJhY2tzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORyEgbm9kZS1jYWNoZSBsZWdhY3kgY2FsbGJhY2sgc3VwcG9ydCB3aWxsIGRyb3AgaW4gdjYueFwiKTtcbiAgICAgICAgICBbXCJnZXRcIiwgXCJtZ2V0XCIsIFwic2V0XCIsIFwiZGVsXCIsIFwidHRsXCIsIFwiZ2V0VHRsXCIsIFwia2V5c1wiLCBcImhhc1wiXS5mb3JFYWNoKChtZXRob2RLZXkpID0+IHtcbiAgICAgICAgICAgIHZhciBvbGRNZXRob2Q7XG4gICAgICAgICAgICAvLyByZWZlcmVuY2UgcmVhbCBmdW5jdGlvblxuICAgICAgICAgICAgb2xkTWV0aG9kID0gdGhpc1ttZXRob2RLZXldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2RLZXldID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAgICAgICB2YXIgY2IsIGVyciwgcmVmLCByZXM7XG4gICAgICAgICAgICAgIHJlZiA9IGFyZ3MsIFsuLi5hcmdzXSA9IHJlZiwgW2NiXSA9IHNwbGljZS5jYWxsKGFyZ3MsIC0xKTtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIGEgY2FsbGJhY2sgaWYgY2IgaXMgZGVmaW5lZCBhbmQgYSBmdW5jdGlvblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNiID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmVzID0gb2xkTWV0aG9kKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgY2IobnVsbCwgcmVzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcjEpIHtcbiAgICAgICAgICAgICAgICAgIGVyciA9IGVycm9yMTtcbiAgICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRNZXRob2QoLi4uYXJncywgY2IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXRpc3RpY3MgY29udGFpbmVyXG4gICAgICAgIHRoaXMuc3RhdHMgPSB7XG4gICAgICAgICAgaGl0czogMCxcbiAgICAgICAgICBtaXNzZXM6IDAsXG4gICAgICAgICAga2V5czogMCxcbiAgICAgICAgICBrc2l6ZTogMCxcbiAgICAgICAgICB2c2l6ZTogMFxuICAgICAgICB9O1xuICAgICAgICAvLyBwcmUgYWxsb2NhdGUgdmFsaWQga2V5dHlwZXMgYXJyYXlcbiAgICAgICAgdGhpcy52YWxpZEtleVR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCJdO1xuICAgICAgICAvLyBpbml0YWxpemUgY2hlY2tpbmcgcGVyaW9kXG4gICAgICAgIHRoaXMuX2NoZWNrRGF0YSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGdldChrZXkpIHtcbiAgICAgICAgdmFyIF9yZXQsIGVycjtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyBoYW5kbGUgaW52YWxpZCBrZXkgdHlwZXNcbiAgICAgICAgaWYgKChlcnIgPSB0aGlzLl9pc0ludmFsaWRLZXkoa2V5KSkgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgZGF0YSBhbmQgaW5jcmVtZXQgc3RhdHNcbiAgICAgICAgaWYgKCh0aGlzLmRhdGFba2V5XSAhPSBudWxsKSAmJiB0aGlzLl9jaGVjayhrZXksIHRoaXMuZGF0YVtrZXldKSkge1xuICAgICAgICAgIHRoaXMuc3RhdHMuaGl0cysrO1xuICAgICAgICAgIF9yZXQgPSB0aGlzLl91bndyYXAodGhpcy5kYXRhW2tleV0pO1xuICAgICAgICAgIC8vIHJldHVybiBkYXRhXG4gICAgICAgICAgcmV0dXJuIF9yZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgbm90IGZvdW5kIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICB0aGlzLnN0YXRzLm1pc3NlcysrO1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWdldChrZXlzKSB7XG4gICAgICAgIHZhciBfZXJyLCBlcnIsIGksIGtleSwgbGVuLCBvUmV0O1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIC8vIGNvbnZlcnQgYSBzdHJpbmcgdG8gYW4gYXJyYXkgb2Ygb25lIGtleVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICBfZXJyID0gdGhpcy5fZXJyb3IoXCJFS0VZU1RZUEVcIik7XG4gICAgICAgICAgdGhyb3cgX2VycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZpbmUgcmV0dXJuXG4gICAgICAgIG9SZXQgPSB7fTtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgICAgaWYgKChlcnIgPSB0aGlzLl9pc0ludmFsaWRLZXkoa2V5KSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBnZXQgZGF0YSBhbmQgaW5jcmVtZW50IHN0YXRzXG4gICAgICAgICAgaWYgKCh0aGlzLmRhdGFba2V5XSAhPSBudWxsKSAmJiB0aGlzLl9jaGVjayhrZXksIHRoaXMuZGF0YVtrZXldKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0cy5oaXRzKys7XG4gICAgICAgICAgICBvUmV0W2tleV0gPSB0aGlzLl91bndyYXAodGhpcy5kYXRhW2tleV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBub3QgZm91bmQgcmV0dXJuIGEgZXJyb3JcbiAgICAgICAgICAgIHRoaXMuc3RhdHMubWlzc2VzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiBhbGwgZm91bmQga2V5c1xuICAgICAgICByZXR1cm4gb1JldDtcbiAgICAgIH1cblxuICAgICAgc2V0KGtleSwgdmFsdWUsIHR0bCkge1xuICAgICAgICB2YXIgX2VyciwgZXJyLCBleGlzdGVudDtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyBjaGVjayBpZiBjYWNoZSBpcyBvdmVyZmxvd2luZ1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1heEtleXMgPiAtMSAmJiB0aGlzLnN0YXRzLmtleXMgPj0gdGhpcy5vcHRpb25zLm1heEtleXMpIHtcbiAgICAgICAgICBfZXJyID0gdGhpcy5fZXJyb3IoXCJFQ0FDSEVGVUxMXCIpO1xuICAgICAgICAgIHRocm93IF9lcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZm9yY2UgdGhlIGRhdGEgdG8gc3RyaW5nXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VTdHJpbmcgJiYgIXR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBkZWZhdWx0IHR0bCBpZiBub3QgcGFzc2VkXG4gICAgICAgIGlmICh0dGwgPT0gbnVsbCkge1xuICAgICAgICAgIHR0bCA9IHRoaXMub3B0aW9ucy5zdGRUVEw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50ZXJuYWwgaGVscGVyIHZhcmlhYmxlc1xuICAgICAgICBleGlzdGVudCA9IGZhbHNlO1xuICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmcgZGF0YSBmcm9tIHN0YXRzXG4gICAgICAgIGlmICh0aGlzLmRhdGFba2V5XSkge1xuICAgICAgICAgIGV4aXN0ZW50ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0YXRzLnZzaXplIC09IHRoaXMuX2dldFZhbExlbmd0aCh0aGlzLl91bndyYXAodGhpcy5kYXRhW2tleV0sIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZVxuICAgICAgICB0aGlzLmRhdGFba2V5XSA9IHRoaXMuX3dyYXAodmFsdWUsIHR0bCk7XG4gICAgICAgIHRoaXMuc3RhdHMudnNpemUgKz0gdGhpcy5fZ2V0VmFsTGVuZ3RoKHZhbHVlKTtcbiAgICAgICAgLy8gb25seSBhZGQgdGhlIGtleXMgYW5kIGtleS1zaXplIGlmIHRoZSBrZXkgaXMgbmV3XG4gICAgICAgIGlmICghZXhpc3RlbnQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRzLmtzaXplICs9IHRoaXMuX2dldEtleUxlbmd0aChrZXkpO1xuICAgICAgICAgIHRoaXMuc3RhdHMua2V5cysrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInNldFwiLCBrZXksIHZhbHVlKTtcbiAgICAgICAgLy8gcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIG1zZXQoa2V5VmFsdWVTZXQpIHtcbiAgICAgICAgdmFyIF9lcnIsIGVyciwgaSwgaiwga2V5LCBrZXlWYWx1ZVBhaXIsIGxlbiwgbGVuMSwgdHRsLCB2YWw7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgY2FjaGUgaXMgb3ZlcmZsb3dpbmdcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXhLZXlzID4gLTEgJiYgdGhpcy5zdGF0cy5rZXlzICsga2V5VmFsdWVTZXQubGVuZ3RoID49IHRoaXMub3B0aW9ucy5tYXhLZXlzKSB7XG4gICAgICAgICAgX2VyciA9IHRoaXMuX2Vycm9yKFwiRUNBQ0hFRlVMTFwiKTtcbiAgICAgICAgICB0aHJvdyBfZXJyO1xuICAgICAgICB9XG5cbi8vIGxvb3Agb3ZlciBrZXlWYWx1ZVNldCB0byB2YWxpZGF0ZSBrZXkgYW5kIHR0bFxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBrZXlWYWx1ZVNldC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGtleVZhbHVlUGFpciA9IGtleVZhbHVlU2V0W2ldO1xuICAgICAgICAgICh7a2V5LCB2YWwsIHR0bH0gPSBrZXlWYWx1ZVBhaXIpO1xuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIHR0bCBhbmQgaXQncyBhIG51bWJlclxuICAgICAgICAgIGlmICh0dGwgJiYgdHlwZW9mIHR0bCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgX2VyciA9IHRoaXMuX2Vycm9yKFwiRVRUTFRZUEVcIik7XG4gICAgICAgICAgICB0aHJvdyBfZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBoYW5kbGUgaW52YWxpZCBrZXkgdHlwZXNcbiAgICAgICAgICBpZiAoKGVyciA9IHRoaXMuX2lzSW52YWxpZEtleShrZXkpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDAsIGxlbjEgPSBrZXlWYWx1ZVNldC5sZW5ndGg7IGogPCBsZW4xOyBqKyspIHtcbiAgICAgICAgICBrZXlWYWx1ZVBhaXIgPSBrZXlWYWx1ZVNldFtqXTtcbiAgICAgICAgICAoe2tleSwgdmFsLCB0dGx9ID0ga2V5VmFsdWVQYWlyKTtcbiAgICAgICAgICB0aGlzLnNldChrZXksIHZhbCwgdHRsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZGVsKGtleXMpIHtcbiAgICAgICAgdmFyIGRlbENvdW50LCBlcnIsIGksIGtleSwgbGVuLCBvbGRWYWw7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gY29udmVydCBrZXlzIHRvIGFuIGFycmF5IG9mIGl0c2VsZlxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICBrZXlzID0gW2tleXNdO1xuICAgICAgICB9XG4gICAgICAgIGRlbENvdW50ID0gMDtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgICAgaWYgKChlcnIgPSB0aGlzLl9pc0ludmFsaWRLZXkoa2V5KSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvbmx5IGRlbGV0ZSBpZiBleGlzdGVudFxuICAgICAgICAgIGlmICh0aGlzLmRhdGFba2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjYWxjIHRoZSBzdGF0c1xuICAgICAgICAgICAgdGhpcy5zdGF0cy52c2l6ZSAtPSB0aGlzLl9nZXRWYWxMZW5ndGgodGhpcy5fdW53cmFwKHRoaXMuZGF0YVtrZXldLCBmYWxzZSkpO1xuICAgICAgICAgICAgdGhpcy5zdGF0cy5rc2l6ZSAtPSB0aGlzLl9nZXRLZXlMZW5ndGgoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHMua2V5cy0tO1xuICAgICAgICAgICAgZGVsQ291bnQrKztcbiAgICAgICAgICAgIC8vIGRlbGV0ZSB0aGUgdmFsdWVcbiAgICAgICAgICAgIG9sZFZhbCA9IHRoaXMuZGF0YVtrZXldO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtrZXldO1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRydWVcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlbFwiLCBrZXksIG9sZFZhbC52KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbENvdW50O1xuICAgICAgfVxuXG4gICAgICB0YWtlKGtleSkge1xuICAgICAgICB2YXIgX3JldDtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBfcmV0ID0gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKChfcmV0ICE9IG51bGwpKSB7XG4gICAgICAgICAgdGhpcy5kZWwoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3JldDtcbiAgICAgIH1cblxuICAgICAgdHRsKGtleSwgdHRsKSB7XG4gICAgICAgIHZhciBlcnI7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgdHRsIHx8ICh0dGwgPSB0aGlzLm9wdGlvbnMuc3RkVFRMKTtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIGV4aXN0ZW50IGRhdGEgYW5kIHVwZGF0ZSB0aGUgdHRsIHZhbHVlXG4gICAgICAgIGlmICgodGhpcy5kYXRhW2tleV0gIT0gbnVsbCkgJiYgdGhpcy5fY2hlY2soa2V5LCB0aGlzLmRhdGFba2V5XSkpIHtcbiAgICAgICAgICAvLyBpZiB0dGwgPCAwIGRlbGV0ZSB0aGUga2V5LiBvdGhlcndpc2UgcmVzZXQgdGhlIHZhbHVlXG4gICAgICAgICAgaWYgKHR0bCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFba2V5XSA9IHRoaXMuX3dyYXAodGhpcy5kYXRhW2tleV0udiwgdHRsLCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVsKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJldHVybiBmYWxzZSBpZiBrZXkgaGFzIG5vdCBiZWVuIGZvdW5kXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdldFR0bChrZXkpIHtcbiAgICAgICAgdmFyIF90dGwsIGVycjtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGludmFsaWQga2V5IHR5cGVzXG4gICAgICAgIGlmICgoZXJyID0gdGhpcy5faXNJbnZhbGlkS2V5KGtleSkpICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIGV4aXN0YW50IGRhdGEgYW5kIHVwZGF0ZSB0aGUgdHRsIHZhbHVlXG4gICAgICAgIGlmICgodGhpcy5kYXRhW2tleV0gIT0gbnVsbCkgJiYgdGhpcy5fY2hlY2soa2V5LCB0aGlzLmRhdGFba2V5XSkpIHtcbiAgICAgICAgICBfdHRsID0gdGhpcy5kYXRhW2tleV0udDtcbiAgICAgICAgICByZXR1cm4gX3R0bDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZXR1cm4gdW5kZWZpbmVkIGlmIGtleSBoYXMgbm90IGJlZW4gZm91bmRcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGtleXMoKSB7XG4gICAgICAgIHZhciBfa2V5cztcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBfa2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuZGF0YSk7XG4gICAgICAgIHJldHVybiBfa2V5cztcbiAgICAgIH1cblxuICAgICAgaGFzKGtleSkge1xuICAgICAgICB2YXIgX2V4aXN0cztcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICBfZXhpc3RzID0gKHRoaXMuZGF0YVtrZXldICE9IG51bGwpICYmIHRoaXMuX2NoZWNrKGtleSwgdGhpcy5kYXRhW2tleV0pO1xuICAgICAgICByZXR1cm4gX2V4aXN0cztcbiAgICAgIH1cblxuICAgICAgZ2V0U3RhdHMoKSB7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHM7XG4gICAgICB9XG5cbiAgICAgIGZsdXNoQWxsKF9zdGFydFBlcmlvZCA9IHRydWUpIHtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICAvLyBwYXJhbWV0ZXIganVzdCBmb3IgdGVzdGluZ1xuXG4gICAgICAgIC8vIHNldCBkYXRhIGVtcHR5XG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICAvLyByZXNldCBzdGF0c1xuICAgICAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgICAgIGhpdHM6IDAsXG4gICAgICAgICAgbWlzc2VzOiAwLFxuICAgICAgICAgIGtleXM6IDAsXG4gICAgICAgICAga3NpemU6IDAsXG4gICAgICAgICAgdnNpemU6IDBcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVzZXQgY2hlY2sgcGVyaW9kXG4gICAgICAgIHRoaXMuX2tpbGxDaGVja1BlcmlvZCgpO1xuICAgICAgICB0aGlzLl9jaGVja0RhdGEoX3N0YXJ0UGVyaW9kKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZmx1c2hcIik7XG4gICAgICB9XG5cbiAgICAgIGZsdXNoU3RhdHMoKSB7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gcmVzZXQgc3RhdHNcbiAgICAgICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgICAgICBoaXRzOiAwLFxuICAgICAgICAgIG1pc3NlczogMCxcbiAgICAgICAgICBrZXlzOiAwLFxuICAgICAgICAgIGtzaXplOiAwLFxuICAgICAgICAgIHZzaXplOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdChcImZsdXNoX3N0YXRzXCIpO1xuICAgICAgfVxuXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICB0aGlzLl9raWxsQ2hlY2tQZXJpb2QoKTtcbiAgICAgIH1cblxuICAgICAgX2NoZWNrRGF0YShzdGFydFBlcmlvZCA9IHRydWUpIHtcbiAgICAgICAgdmFyIGtleSwgcmVmLCB2YWx1ZTtcbiAgICAgICAgYm91bmRNZXRob2RDaGVjayh0aGlzLCBOb2RlQ2FjaGUpO1xuICAgICAgICByZWYgPSB0aGlzLmRhdGE7XG4gICAgICAgIC8vIHJ1biB0aGUgaG91c2VrZWVwaW5nIG1ldGhvZFxuICAgICAgICBmb3IgKGtleSBpbiByZWYpIHtcbiAgICAgICAgICB2YWx1ZSA9IHJlZltrZXldO1xuICAgICAgICAgIHRoaXMuX2NoZWNrKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFBlcmlvZCAmJiB0aGlzLm9wdGlvbnMuY2hlY2twZXJpb2QgPiAwKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1RpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX2NoZWNrRGF0YSwgdGhpcy5vcHRpb25zLmNoZWNrcGVyaW9kICogMTAwMCwgc3RhcnRQZXJpb2QpO1xuICAgICAgICAgIGlmICgodGhpcy5jaGVja1RpbWVvdXQgIT0gbnVsbCkgJiYgKHRoaXMuY2hlY2tUaW1lb3V0LnVucmVmICE9IG51bGwpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrVGltZW91dC51bnJlZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAjIyBfa2lsbENoZWNrUGVyaW9kXG5cbiAgICAgIC8vIHN0b3AgdGhlIGNoZWNrZGF0YSBwZXJpb2QuIE9ubHkgbmVlZGVkIHRvIGFib3J0IHRoZSBzY3JpcHQgaW4gdGVzdGluZyBtb2RlLlxuICAgICAgX2tpbGxDaGVja1BlcmlvZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRoaXMuY2hlY2tUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfY2hlY2soa2V5LCBkYXRhKSB7XG4gICAgICAgIHZhciBfcmV0dmFsO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIF9yZXR2YWwgPSB0cnVlO1xuICAgICAgICAvLyBkYXRhIGlzIGludmFsaWQgaWYgdGhlIHR0bCBpcyB0b28gb2xkIGFuZCBpcyBub3QgMFxuICAgICAgICAvLyBjb25zb2xlLmxvZyBkYXRhLnQgPCBEYXRlLm5vdygpLCBkYXRhLnQsIERhdGUubm93KClcbiAgICAgICAgaWYgKGRhdGEudCAhPT0gMCAmJiBkYXRhLnQgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWxldGVPbkV4cGlyZSkge1xuICAgICAgICAgICAgX3JldHZhbCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kZWwoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KFwiZXhwaXJlZFwiLCBrZXksIHRoaXMuX3Vud3JhcChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXR2YWw7XG4gICAgICB9XG5cbiAgICAgIF9pc0ludmFsaWRLZXkoa2V5KSB7XG4gICAgICAgIHZhciByZWY7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgaWYgKHJlZiA9IHR5cGVvZiBrZXksIGluZGV4T2YuY2FsbCh0aGlzLnZhbGlkS2V5VHlwZXMsIHJlZikgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKFwiRUtFWVRZUEVcIiwge1xuICAgICAgICAgICAgdHlwZTogdHlwZW9mIGtleVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF93cmFwKHZhbHVlLCB0dGwsIGFzQ2xvbmUgPSB0cnVlKSB7XG4gICAgICAgIHZhciBsaXZldGltZSwgbm93LCBvUmV0dXJuLCB0dGxNdWx0aXBsaWNhdG9yO1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnVzZUNsb25lcykge1xuICAgICAgICAgIGFzQ2xvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWZpbmUgdGhlIHRpbWUgdG8gbGl2ZVxuICAgICAgICBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBsaXZldGltZSA9IDA7XG4gICAgICAgIHR0bE11bHRpcGxpY2F0b3IgPSAxMDAwO1xuICAgICAgICAvLyB1c2UgZ2l2ZW4gdHRsXG4gICAgICAgIGlmICh0dGwgPT09IDApIHtcbiAgICAgICAgICBsaXZldGltZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAodHRsKSB7XG4gICAgICAgICAgbGl2ZXRpbWUgPSBub3cgKyAodHRsICogdHRsTXVsdGlwbGljYXRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIHN0YW5kYXJkIHR0bFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RkVFRMID09PSAwKSB7XG4gICAgICAgICAgICBsaXZldGltZSA9IHRoaXMub3B0aW9ucy5zdGRUVEw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpdmV0aW1lID0gbm93ICsgKHRoaXMub3B0aW9ucy5zdGRUVEwgKiB0dGxNdWx0aXBsaWNhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIHRoZSB3cmFwcGVkIHZhbHVlXG4gICAgICAgIHJldHVybiBvUmV0dXJuID0ge1xuICAgICAgICAgIHQ6IGxpdmV0aW1lLFxuICAgICAgICAgIHY6IGFzQ2xvbmUgPyBjbG9uZSh2YWx1ZSkgOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAjIyBfdW53cmFwXG5cbiAgICAgIC8vIGludGVybmFsIG1ldGhvZCB0byBleHRyYWN0IGdldCB0aGUgdmFsdWUgb3V0IG9mIHRoZSB3cmFwcGVkIHZhbHVlXG4gICAgICBfdW53cmFwKHZhbHVlLCBhc0Nsb25lID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy51c2VDbG9uZXMpIHtcbiAgICAgICAgICBhc0Nsb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnYgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChhc0Nsb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmUodmFsdWUudik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS52O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gIyMgX2dldEtleUxlbmd0aFxuXG4gICAgICAvLyBpbnRlcm5hbCBtZXRob2QgdGhlIGNhbGN1bGF0ZSB0aGUga2V5IGxlbmd0aFxuICAgICAgX2dldEtleUxlbmd0aChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleS50b1N0cmluZygpLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgX2dldFZhbExlbmd0aCh2YWx1ZSkge1xuICAgICAgICBib3VuZE1ldGhvZENoZWNrKHRoaXMsIE5vZGVDYWNoZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaXMgYSBTdHJpbmcgZ2V0IHRoZSByZWFsIGxlbmd0aFxuICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmZvcmNlU3RyaW5nKSB7XG4gICAgICAgICAgLy8gZm9yY2Ugc3RyaW5nIGlmIGl0J3MgZGVmaW5lZCBhbmQgbm90IHBhc3NlZFxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgYW4gQXJyYXkgbXVsdGlwbHkgZWFjaCBlbGVtZW50IHdpdGggYSBkZWZpbmVkIGRlZmF1bHQgbGVuZ3RoXG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hcnJheVZhbHVlU2l6ZSAqIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKHZhbHVlICE9IG51bGwgPyB2YWx1ZS50aGVuIDogdm9pZCAwKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgYSBQcm9taXNlLCB1c2UgZGVmaW5lZCBkZWZhdWx0XG4gICAgICAgICAgLy8gKGNhbid0IGNhbGN1bGF0ZSBhY3R1YWwvcmVzb2x2ZWQgdmFsdWUgc2l6ZSBzeW5jaHJvbm91c2x5KVxuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucHJvbWlzZVZhbHVlU2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIEJ1ZmZlciAhPT0gbnVsbCA/IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgOiB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKCh2YWx1ZSAhPSBudWxsKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgZGF0YSBpcyBhbiBPYmplY3QgbXVsdGlwbHkgZWFjaCBlbGVtZW50IHdpdGggYSBkZWZpbmVkIGRlZmF1bHQgbGVuZ3RoXG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vYmplY3RWYWx1ZVNpemUgKiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZhdWx0IGZhbGxiYWNrXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2Vycm9yKHR5cGUsIGRhdGEgPSB7fSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIGVycm9yIG9iamVjdFxuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBlcnJvci5uYW1lID0gdHlwZTtcbiAgICAgICAgZXJyb3IuZXJyb3Jjb2RlID0gdHlwZTtcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9IHRoaXMuRVJST1JTW3R5cGVdICE9IG51bGwgPyB0aGlzLkVSUk9SU1t0eXBlXShkYXRhKSA6IFwiLVwiO1xuICAgICAgICBlcnJvci5kYXRhID0gZGF0YTtcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBlcnJvciBvYmplY3RcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuXG4gICAgICBfaW5pdEVycm9ycygpIHtcbiAgICAgICAgdmFyIF9lcnJNc2csIF9lcnJULCByZWY7XG4gICAgICAgIGJvdW5kTWV0aG9kQ2hlY2sodGhpcywgTm9kZUNhY2hlKTtcbiAgICAgICAgdGhpcy5FUlJPUlMgPSB7fTtcbiAgICAgICAgcmVmID0gdGhpcy5fRVJST1JTO1xuICAgICAgICBmb3IgKF9lcnJUIGluIHJlZikge1xuICAgICAgICAgIF9lcnJNc2cgPSByZWZbX2VyclRdO1xuICAgICAgICAgIHRoaXMuRVJST1JTW19lcnJUXSA9IHRoaXMuY3JlYXRlRXJyb3JNZXNzYWdlKF9lcnJNc2cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNyZWF0ZUVycm9yTWVzc2FnZShlcnJNc2cpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gZXJyTXNnLnJlcGxhY2UoXCJfX2tleVwiLCBhcmdzLnR5cGUpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgfTtcblxuICAgIE5vZGVDYWNoZS5wcm90b3R5cGUuX0VSUk9SUyA9IHtcbiAgICAgIFwiRU5PVEZPVU5EXCI6IFwiS2V5IGBfX2tleWAgbm90IGZvdW5kXCIsXG4gICAgICBcIkVDQUNIRUZVTExcIjogXCJDYWNoZSBtYXgga2V5cyBhbW91bnQgZXhjZWVkZWRcIixcbiAgICAgIFwiRUtFWVRZUEVcIjogXCJUaGUga2V5IGFyZ3VtZW50IGhhcyB0byBiZSBvZiB0eXBlIGBzdHJpbmdgIG9yIGBudW1iZXJgLiBGb3VuZDogYF9fa2V5YFwiLFxuICAgICAgXCJFS0VZU1RZUEVcIjogXCJUaGUga2V5cyBhcmd1bWVudCBoYXMgdG8gYmUgYW4gYXJyYXkuXCIsXG4gICAgICBcIkVUVExUWVBFXCI6IFwiVGhlIHR0bCBhcmd1bWVudCBoYXMgdG8gYmUgYSBudW1iZXIuXCJcbiAgICB9O1xuXG4gICAgcmV0dXJuIE5vZGVDYWNoZTtcblxuICB9KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-cache/lib/node_cache.js\n");

/***/ })

};
;